# ðŸ¤– Autogenerate Migration Guide

## Overview

Seperti Alembic untuk SQLAlchemy, sistem ini bisa **automatically detect** perubahan schema dari model definitions dan generate migration code.

---

## ðŸ“‹ How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MongoDB Models      â”‚  Define your schema
â”‚ (Python Classes)    â”‚  in mongodb_schema.py
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Autogenerate        â”‚  Compare models vs
â”‚ Comparator          â”‚  current database
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Migration Code      â”‚  Auto-generate
â”‚ Generator           â”‚  migration file
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸš€ Quick Start

### Step 1: Define Your Schema Models

```python
# baseapp/models/mongodb_schema.py

from baseapp.models.mongodb_schema import Collection, Index

class Wallet(Collection):
    """User wallet collection"""
    __collection_name__ = "wallet"
    __indexes__ = [
        Index([("uid", 1), ("org_id", 1)], name="uid_org_idx", unique=True),
        Index("rec_date"),
        Index("coins")
    ]

class WalletHistory(Collection):
    """Wallet transaction history"""
    __collection_name__ = "wallet_history"
    __indexes__ = [
        Index("wallet_id"),
        Index("rec_date"),
        Index([("wallet_id", 1), ("rec_date", -1)], name="wallet_date_idx")
    ]

# Register in ALL_COLLECTIONS at bottom of file
ALL_COLLECTIONS = [
    # ... existing collections
    Wallet,
    WalletHistory
]
```

### Step 2: Generate Migration

```bash
# Autogenerate will detect NEW collections and indexes
python manage.py revision -m "add wallet collections" --autogenerate
```

Output:
```
ðŸ”¨ Creating new revision: add wallet collections
   Running autogenerate...
âœ“ Created autogenerated revision: 20241210150000_add_wallet_collections.py
  Revision ID: 20241210150000
  Edit: migrations/versions/20241210150000_add_wallet_collections.py

Detected changes:
  - New collections: wallet, wallet_history
  - New indexes on wallet: 3 index(es)
  - New indexes on wallet_history: 3 index(es)
```

### Step 3: Review Generated Code

```python
# migrations/versions/20241210150000_add_wallet_collections.py
"""
add wallet collections

Autogenerated migration:
- New collections: wallet, wallet_history
- New indexes on wallet: 3 index(es)
- New indexes on wallet_history: 3 index(es)
"""

revision = '20241210150000'
down_revision = '20241210140000'
branch_labels = None
depends_on = None


def upgrade(env):
    """Apply schema changes"""
    # Create collection: wallet
    env.create_collection('wallet')
    env.db['wallet'].create_index([("uid", 1), ("org_id", 1)], name='uid_org_idx', unique=True)
    env.db['wallet'].create_index("rec_date")
    env.db['wallet'].create_index("coins")
    
    # Create collection: wallet_history
    env.create_collection('wallet_history')
    env.db['wallet_history'].create_index("wallet_id")
    env.db['wallet_history'].create_index("rec_date")
    env.db['wallet_history'].create_index([("wallet_id", 1), ("rec_date", -1)], name='wallet_date_idx')


def downgrade(env):
    """Revert schema changes"""
    env.drop_collection('wallet')
    env.drop_collection('wallet_history')
```

### Step 4: Apply Migration

```bash
python manage.py upgrade head
```

---

## ðŸ“ Complete Example Workflow

### Scenario: Add Complete Wallet System

#### Step 1: Define All Models

```python
# baseapp/models/mongodb_schema.py

class Wallet(Collection):
    """User wallet"""
    __collection_name__ = "wallet"
    __indexes__ = [
        Index([("uid", 1), ("org_id", 1)], name="uid_org_idx", unique=True),
        Index("rec_date"),
        Index("coins"),
        Index("rcoins")
    ]


class TopUp(Collection):
    """Top up transactions"""
    __collection_name__ = "top_up"
    __indexes__ = [
        Index([("uid", 1), ("org_id", 1)], name="uid_org_idx"),
        Index("rec_date"),
        Index("amount")
    ]


class PartnerWallet(Collection):
    """Partner wallet"""
    __collection_name__ = "partner_wallet"
    __indexes__ = [
        Index([("uid", 1), ("org_id", 1)], name="uid_org_idx", unique=True),
        Index("rec_date"),
        Index("coins")
    ]


class WalletHistory(Collection):
    """Wallet history"""
    __collection_name__ = "wallet_history"
    __indexes__ = [
        Index("wallet_id"),
        Index("rec_date"),
        Index("ctype"),
        Index("ref_id"),
        Index([("wallet_id", 1), ("rec_date", -1)], name="wallet_date_idx")
    ]


class PartnerWalletHistory(Collection):
    """Partner wallet history"""
    __collection_name__ = "partner_wallet_history"
    __indexes__ = [
        Index("wallet_id"),
        Index("rec_date"),
        Index("ctype"),
        Index([("wallet_id", 1), ("rec_date", -1)], name="wallet_date_idx")
    ]


# Add to ALL_COLLECTIONS
ALL_COLLECTIONS = [
    # ... existing
    Wallet,
    TopUp,
    PartnerWallet,
    WalletHistory,
    PartnerWalletHistory
]
```

#### Step 2: Autogenerate

```bash
python manage.py revision -m "add complete wallet system" --autogenerate
```

Output:
```
âœ“ Created autogenerated revision: 20241210150000_add_complete_wallet_system.py

Detected changes:
  - New collections: wallet, top_up, partner_wallet, wallet_history, partner_wallet_history
  - Total new indexes: 17 index(es)
```

#### Step 3: Verify and Apply

```bash
# Review the generated file
cat migrations/versions/20241210150000_add_complete_wallet_system.py

# Test in dev
python manage.py upgrade head

# Check status
python manage.py current
```

---

## ðŸŽ¯ Comparison: Manual vs Autogenerate

### Manual Migration (Old Way)

```bash
# 1. Create empty migration
python manage.py revision -m "add wallet"

# 2. Manually write ALL this code:
```

```python
def upgrade(env):
    env.create_collection('wallet')
    env.db['wallet'].create_index([("uid", 1), ("org_id", 1)], unique=True)
    env.db['wallet'].create_index("rec_date")
    env.db['wallet'].create_index("coins")
    # ... 20 more lines

def downgrade(env):
    env.drop_collection('wallet')
    # ... more code
```

**Time:** 15-30 minutes  
**Error-prone:** Yes  
**Tedious:** Very

---

### Autogenerate (New Way)

```bash
# 1. Define models (once)
# Edit: baseapp/models/mongodb_schema.py
# Add: Wallet class

# 2. Autogenerate
python manage.py revision -m "add wallet" --autogenerate
```

**Time:** 2-3 minutes  
**Error-prone:** No  
**Tedious:** Not at all

---

## ðŸ” What Can Be Autogenerated?

### âœ… Fully Supported

1. **New Collections**
   ```python
   # Define in models
   class MyCollection(Collection):
       __collection_name__ = "my_collection"
   
   # Autogenerate detects and creates
   ```

2. **New Indexes**
   ```python
   # Add to model
   __indexes__ = [
       Index("new_field"),
       Index([("field1", 1), ("field2", -1)])
   ]
   
   # Autogenerate creates indexes
   ```

3. **Initial Data**
   ```python
   # Define in model
   __initial_data__ = [
       {"_id": "item1", "value": "data"}
   ]
   
   # Autogenerate inserts data
   ```

### âš ï¸ Needs Manual Code

1. **Data Migrations**
   ```python
   # Must write manually
   def upgrade(env):
       env.db['users'].update_many(
           {"old_field": {"$exists": True}},
           {"$rename": {"old_field": "new_field"}}
       )
   ```

2. **Complex Transformations**
   ```python
   # Must write manually
   def upgrade(env):
       for user in env.db['users'].find():
           new_value = transform(user['old_value'])
           env.db['users'].update_one(
               {"_id": user["_id"]},
               {"$set": {"new_field": new_value}}
           )
   ```

3. **Conditional Logic**
   ```python
   # Must write manually
   def upgrade(env):
       if 'temp_collection' in env.collections:
           # migrate data
           pass
   ```

---

## ðŸ’¡ Best Practices

### 1. Always Review Generated Code

```bash
# Generate
python manage.py revision -m "changes" --autogenerate

# ALWAYS review before applying
cat migrations/versions/TIMESTAMP_changes.py

# Make manual edits if needed
nano migrations/versions/TIMESTAMP_changes.py

# Then apply
python manage.py upgrade head
```

### 2. Combine with Manual Code

```python
# Generated code
def upgrade(env):
    # Autogenerated: create collection
    env.create_collection('wallet')
    env.db['wallet'].create_index([("uid", 1)])
    
    # MANUAL: Add data migration
    # Migrate existing user balances to new wallet collection
    for user in env.db['_user'].find({"balance": {"$exists": True}}):
        env.db['wallet'].insert_one({
            "_id": str(uuid.uuid4()),
            "uid": user["_id"],
            "org_id": user["org_id"],
            "coins": user["balance"],
            "rcoins": 0
        })
    
    # MANUAL: Clean up old field
    env.db['_user'].update_many({}, {"$unset": {"balance": ""}})
```

### 3. Use for Initial Schema

```bash
# First time: define ALL collections in models
# Then autogenerate initial schema
python manage.py revision -m "initial schema" --autogenerate

# Result: Complete initial migration without typing!
```

### 4. Incremental Changes

```python
# Day 1: Define User collection
class User(Collection):
    __collection_name__ = "_user"
    __indexes__ = [Index("email")]

# Generate
python manage.py revision -m "add users" --autogenerate

# Day 2: Add index to User
class User(Collection):
    __indexes__ = [
        Index("email"),
        Index("username")  # NEW
    ]

# Generate again
python manage.py revision -m "add username index" --autogenerate

# Only the NEW index is generated!
```

---

## ðŸŽ“ Advanced Usage

### Custom Index Types

```python
class GeoCollection(Collection):
    """Collection with geospatial index"""
    __collection_name__ = "locations"
    __indexes__ = [
        Index([("location", "2dsphere")], name="geo_idx")
    ]
```

### Text Search Indexes

```python
class SearchableContent(Collection):
    """Content with text search"""
    __collection_name__ = "content"
    __indexes__ = [
        Index([("title", "text"), ("description", "text")], name="search_idx")
    ]
```

### Sparse Indexes

```python
class OptionalField(Collection):
    """Collection with optional field index"""
    __collection_name__ = "items"
    __indexes__ = [
        Index("optional_field", sparse=True)
    ]
```

---

## ðŸ”„ Workflow Integration

### Development Workflow

```bash
# 1. Define models
nano baseapp/models/mongodb_schema.py

# 2. Autogenerate
python manage.py revision -m "add feature" --autogenerate

# 3. Review
cat migrations/versions/*.py

# 4. Test
python manage.py upgrade head

# 5. Commit
git add baseapp/models/mongodb_schema.py
git add migrations/
git commit -m "Add wallet feature"
```

### Team Collaboration

```bash
# Developer A: Add wallet models
# commits: mongodb_schema.py + migration file

# Developer B: Pull changes
git pull

# Developer B: Apply migrations
python manage.py upgrade head

# Developer B: Add loyalty models
# Autogenerate only detects NEW changes
python manage.py revision -m "add loyalty" --autogenerate

# No conflicts!
```

---

## âš ï¸ Limitations

### What Autogenerate CANNOT Do

1. **Detect Field Removals**
   - MongoDB is schemaless, can't detect removed fields
   - Must write manual migration to remove data

2. **Detect Data Type Changes**
   - Can't detect if field changes from string to int
   - Must write manual migration

3. **Detect Renamed Fields**
   - Can't distinguish rename from remove+add
   - Use manual `$rename` operation

4. **Complex Business Logic**
   - Can't generate application-specific logic
   - Always requires manual code

---

## ðŸ“Š Comparison Table

| Feature | Manual | Autogenerate |
|---------|--------|--------------|
| **Time to create migration** | 15-30 min | 2-3 min |
| **Error rate** | High | Low |
| **Consistency** | Varies | Always consistent |
| **Learning curve** | Medium | Low |
| **Flexibility** | High | Medium (can edit) |
| **Data migrations** | âœ… Full control | âš ï¸ Need manual code |
| **Schema changes** | âš ï¸ Tedious | âœ… Automatic |
| **Initial setup** | âš ï¸ Lots of typing | âœ… One command |

---

## âœ… Summary

**When to use Autogenerate:**
- âœ… Creating new collections
- âœ… Adding indexes
- âœ… Initial schema setup
- âœ… Simple schema changes

**When to write manual:**
- âœ… Data transformations
- âœ… Complex logic
- âœ… Renaming fields
- âœ… Conditional operations

**Best approach:**
```bash
# Use autogenerate as starting point
python manage.py revision -m "feature" --autogenerate

# Then edit to add manual logic if needed
nano migrations/versions/TIMESTAMP_feature.py

# Apply
python manage.py upgrade head
```

**Golden Rule:**  
> Autogenerate saves time on schema changes, but you still need to think about data migrations.

---

## ðŸŽ¯ Quick Reference

```bash
# Create with autogenerate
python manage.py revision -m "description" --autogenerate

# Create without autogenerate (manual)
python manage.py revision -m "description"

# Apply migrations
python manage.py upgrade head

# Check what would be generated (without creating file)
python -c "
from baseapp.services.database.autogenerate import autogenerate_migration
code, has_changes = autogenerate_migration('test')
print('Has changes:', has_changes)
"
```

Ready to save hours of manual migration writing! ðŸš€